<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no" />
<title>JumpQuest.Lite</title>
<style>
  :root{
    --bg:#0f1724; --ui:#0b1220; --accent:#ffd166; --accent2:#06d6a0; --muted:#94a3b8;
  }
  html,body{height:100%;margin:0;font-family:Inter, system-ui, Arial, sans-serif;background:var(--bg); color:#e6eef8;}
  #gameRoot{display:flex;flex-direction:column;height:100vh;align-items:center;justify-content:center;position:relative;overflow:hidden;}
  canvas{background:linear-gradient(180deg,#071027 0%, #0b1930 60%);border-radius:12px;box-shadow:0 8px 30px rgba(0,0,0,0.7);}
  /* Main Menu */
  #menu {
    position:absolute; z-index:40; inset:0; display:flex;align-items:center;justify-content:center;
    background:linear-gradient(180deg, rgba(1,6,12,0.6), rgba(2,10,18,0.6));
    backdrop-filter: blur(4px);
  }
  .menuCard{
    width:min(720px,92%); max-width:920px; padding:28px;border-radius:12px; background:linear-gradient(180deg,#071429,#0a1830);
    box-shadow: 0 10px 30px rgba(0,0,0,0.6); border:1px solid rgba(255,255,255,0.03);
  }
  h1{margin:0;font-size:34px;color:var(--accent);letter-spacing:1px}
  .subtitle{color:var(--muted); margin-top:8px}
  .controlsRow{display:flex;gap:12px;margin-top:18px;flex-wrap:wrap}
  button, select{
    background:linear-gradient(180deg,#0b2236,#061826); color:#e6eef8; border:none;padding:10px 14px;border-radius:8px;cursor:pointer;
    box-shadow:0 6px 14px rgba(2,8,12,0.6);
  }
  button.primary{background:linear-gradient(180deg,var(--accent),#ffb84a); color:#071429; font-weight:700;}
  .small{font-size:14px;padding:8px 10px}
  .muted{color:var(--muted);font-size:13px}
  .menuFooter{display:flex;justify-content:space-between;margin-top:14px;color:var(--muted);font-size:13px}
  /* HUD */
  #hud{position:absolute;top:12px;left:12px;z-index:30;display:flex;flex-direction:column;gap:8px;pointer-events:none}
  .hudRow{display:flex;gap:8px;align-items:center;background:rgba(2,10,18,0.6);padding:8px 12px;border-radius:10px;border:1px solid rgba(255,255,255,0.03)}
  .hudItem{font-weight:600}
  #rightHud{position:absolute;top:12px;right:12px;z-index:30;display:flex;flex-direction:column;gap:8px;pointer-events:none}
  /* Bottom mobile controls */
  #mobileControls{position:fixed;left:12px;right:12px;bottom:12px;z-index:35;display:flex;justify-content:space-between;pointer-events:none}
  .btnGroup{display:flex;gap:10px;align-items:center;pointer-events:auto}
  .circleBtn{
    width:68px;height:68px;border-radius:14px;background:linear-gradient(180deg, rgba(255,255,255,0.04), rgba(0,0,0,0.15));
    border:1px solid rgba(255,255,255,0.04);display:flex;align-items:center;justify-content:center;font-weight:700;font-size:20px;color:#fff;
    touch-action:none; user-select:none;
  }
  .circleBtn:active{transform:translateY(2px)}
  .jumpBtn{width:88px;height:88px;border-radius:20px;font-size:22px}
  /* On-Screen messages */
  #msg{position:absolute;left:50%;transform:translateX(-50%);top:60px;z-index:35;font-weight:700;padding:8px 14px;border-radius:8px;background:rgba(2,8,12,0.6);display:none}
  /* Responsive: hide mobile controls on large screens */
  @media(min-width:900px){
    #mobileControls{display:none}
  }
  /* Buttons row for pause/restart */
  #topControls{position:absolute;top:12px;left:50%;transform:translateX(-50%);z-index:30;display:flex;gap:8px;pointer-events:auto}
  .tiny{padding:6px 8px;border-radius:8px;font-size:13px}
</style>
</head>
<body>
<div id="gameRoot">
  <!-- HUD -->
  <div id="hud" aria-hidden="true">
    <div class="hudRow"><div class="hudItem" id="scoreLabel">Score: 0</div></div>
    <div class="hudRow"><div class="hudItem" id="coinLabel">Coins: 0</div></div>
  </div>
  <div id="rightHud" aria-hidden="true">
    <div class="hudRow"><div class="hudItem" id="levelLabel">Level: 1</div></div>
    <div class="hudRow"><div class="hudItem" id="livesLabel">Lives: 3</div></div>
  </div>

  <!-- top controls -->
  <div id="topControls">
    <button id="pauseBtn" class="tiny">Pause</button>
    <button id="restartBtn" class="tiny">Restart</button>
  </div>

  <!-- message -->
  <div id="msg"></div>

  <!-- Canvas -->
  <canvas id="gameCanvas" width="1024" height="576" aria-label="JumpQuest.Lite game"></canvas>

  <!-- Mobile Controls -->
  <div id="mobileControls" aria-hidden="true">
    <div class="btnGroup">
      <div id="leftBtn" class="circleBtn small">‚óÄ</div>
      <div id="rightBtn" class="circleBtn small">‚ñ∂</div>
    </div>
    <div class="btnGroup">
      <div id="jumpBtn" class="circleBtn jumpBtn">‚Üë</div>
    </div>
  </div>

  <!-- Main Menu -->
  <div id="menu" role="dialog" aria-modal="true">
    <div class="menuCard">
      <h1>JumpQuest.Lite</h1>
      <div class="subtitle">A little platformer ‚Äî collect coins, avoid enemies, and reach the finish!</div>

      <div style="height:14px"></div>

      <div class="controlsRow">
        <label class="muted" for="difficulty">Difficulty:</label>
        <select id="difficulty" aria-label="Choose difficulty">
          <option value="easy">Easy</option>
          <option value="normal" selected>Normal</option>
          <option value="hard">Hard</option>
        </select>

        <label class="muted" for="levelSelect">Start Level:</label>
        <select id="levelSelect" aria-label="Choose level">
          <option value="0">Level 1</option>
          <option value="1">Level 2</option>
          <option value="2">Level 3</option>
        </select>

        <button id="startBtn" class="primary">Start</button>
        <button id="howBtn">How to Play</button>
      </div>

      <div style="height:12px"></div>

      <div class="menuFooter">
        <div>Made with ‚ù§Ô∏è ‚Äî JumpQuest.Lite</div>
        <div class="muted">Controls: A/D or ‚Üê ‚Üí, Space to jump. Mobile buttons are at the bottom.</div>
      </div>
    </div>
  </div>

</div>

<script>
/* ---------------------------
   JumpQuest.Lite
   Single-file 2D platformer
   --------------------------- */

(() => {
  // Canvas & context
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d', { alpha: false });

  // Responsive canvas scaling
  function fitCanvas() {
    const ratio = canvas.width / canvas.height;
    const maxw = Math.min(window.innerWidth - 24, 1280);
    const maxh = window.innerHeight - 24;
    let w = maxw, h = Math.round(w / ratio);
    if (h > maxh) { h = maxh; w = Math.round(h * ratio); }
    canvas.style.width = w + 'px'; canvas.style.height = h + 'px';
  }
  window.addEventListener('resize', fitCanvas);
  fitCanvas();

  // HUD & UI references
  const menu = document.getElementById('menu');
  const startBtn = document.getElementById('startBtn');
  const howBtn = document.getElementById('howBtn');
  const difficultySelect = document.getElementById('difficulty');
  const levelSelect = document.getElementById('levelSelect');
  const scoreLabel = document.getElementById('scoreLabel');
  const coinLabel = document.getElementById('coinLabel');
  const levelLabel = document.getElementById('levelLabel');
  const livesLabel = document.getElementById('livesLabel');
  const msg = document.getElementById('msg');
  const pauseBtn = document.getElementById('pauseBtn');
  const restartBtn = document.getElementById('restartBtn');

  // Mobile buttons
  const leftBtn = document.getElementById('leftBtn');
  const rightBtn = document.getElementById('rightBtn');
  const jumpBtn = document.getElementById('jumpBtn');

  // Game state
  let running = false;
  let paused = false;
  let difficulty = 'normal';
  let currentLevelIndex = 0;
  let lives = 3;
  let score = 0;
  let coins = 0;

  // Physics parameters (modified by difficulty)
  let GRAVITY = 1600; // px/s^2
  let MOVE_SPEED = 320; // px/s
  let JUMP_V = 620; // px/s
  let enemySpeedFactor = 1;

  // Camera smoothing
  const camera = { x:0, y:0, width: canvas.width, height: canvas.height, smooth: 0.12 };

  // Input state
  const keys = { left:false, right:false, jump:false };
  let touchState = { left:false, right:false, jump:false };

  // Time
  let lastTime = performance.now();

  // Level definition format:
  // { width, height, spawn:{x,y}, platforms:[{x,y,w,h}], coins:[{x,y}], enemies:[{x,y,patrolW}], finishX }
  const levels = [
    // Level 1 - gentle intro
    {
      name: 'Meadow Start',
      width: 3200, height: 720,
      spawn: {x:140, y:420},
      platforms: [
        {x:0,y:520,w:800,h:200}, {x:900,y:440,w:320,h:40}, {x:1240,y:360,w:220,h:40},
        {x:1600,y:480,w:400,h:40}, {x:2100,y:420,w:200,h:40}, {x:2400,y:360,w:280,h:40},
        {x:2800,y:480,w:400,h:200}
      ],
      coins: [
        {x:420,y:420},{x:460,y:420},{x:500,y:420},
        {x:980,y:380},{x:1280,y:300},{x:1620,y:440},
        {x:2420,y:320}
      ],
      enemies: [
        {x:980,y:400,patrolW:180}, {x:2200,y:390,patrolW:120}
      ],
      finishX: 3000
    },

    // Level 2 - platforms & gaps
    {
      name: 'Cliffside',
      width: 3800, height: 720,
      spawn: {x:120,y:430},
      platforms: [
        {x:0,y:520,w:900,h:200}, {x:980,y:420,w:140,h:20}, {x:1140,y:350,w:140,h:20},
        {x:1320,y:280,w:140,h:20}, {x:1600,y:460,w:420,h:20}, {x:2100,y:400,w:180,h:20},
        {x:2400,y:320,w:120,h:20}, {x:2600,y:420,w:260,h:20}, {x:3200,y:480,w:400,h:200}
      ],
      coins: [
        {x:1020,y:380},{x:1180,y:320},{x:1340,y:250},{x:1620,y:420},{x:2420,y:280},
        {x:2650,y:380}
      ],
      enemies: [
        {x:1500,y:440,patrolW:220}, {x:2500,y:380,patrolW:150}, {x:3000,y:440,patrolW:180}
      ],
      finishX: 3350
    },

    // Level 3 - tighter, more enemies
    {
      name: 'Factory Ruins',
      width: 4200, height: 720,
      spawn: {x:160,y:430},
      platforms: [
        {x:0,y:520,w:720,h:200}, {x:800,y:460,w:220,h:20}, {x:1060,y:400,w:220,h:20},
        {x:1330,y:340,w:220,h:20}, {x:1700,y:480,w:340,h:20}, {x:2080,y:420,w:220,h:20},
        {x:2360,y:360,w:220,h:20}, {x:2680,y:300,w:220,h:20}, {x:3000,y:480,w:1200,h:240}
      ],
      coins: Array.from({length:12}).map((_,i)=>({x:880 + i*190, y:420 - (i%3)*40})),
      enemies: [
        {x:900,y:420,patrolW:160}, {x:1300,y:360,patrolW:140}, {x:2100,y:380,patrolW:200},
        {x:2500,y:320,patrolW:160}, {x:3100,y:440,patrolW:220}
      ],
      finishX: 3800
    }
  ];

  // Player
  const player = {
    x: 100, y: 400, w: 40, h: 56,
    vx:0, vy:0, onGround:false, canDoubleJump:false,
    invulnTime:0
  };

  // Entities
  let coinsArray = [];
  let enemiesArray = [];
  let platforms = [];
  let finishX = 0;

  // Helpers
  function clamp(v,a,b){return Math.max(a,Math.min(b,v));}
  function rectsOverlap(a,b){return !(a.x+a.w < b.x || a.x > b.x+b.w || a.y+a.h < b.y || a.y > b.y+b.h);}

  // Initialize level
  function loadLevel(idx){
    const L = levels[idx];
    levelLabel.textContent = `Level: ${idx+1} ‚Äî ${L.name}`;
    player.x = L.spawn.x; player.y = L.spawn.y; player.vx = 0; player.vy = 0;
    coinsArray = L.coins.map(c => ({...c, picked:false}));
    enemiesArray = L.enemies.map(e => ({...e, dir:1, baseX:e.x, speed: (80 * enemySpeedFactor)}));
    platforms = L.platforms.map(p => ({...p}));
    finishX = L.finishX;
    camera.x = player.x - canvas.width/2;
    camera.y = 0;
    currentLevelIndex = idx;
    updateHUD();
    showMessage(`Level ${idx+1}: ${L.name}`, 1800);
  }

  function updateHUD(){
    scoreLabel.textContent = `Score: ${score}`;
    coinLabel.textContent = `Coins: ${coins}`;
    livesLabel.textContent = `Lives: ${lives}`;
  }

  // Difficulty apply
  function applyDifficulty(mode){
    difficulty = mode;
    if (mode === 'easy'){ GRAVITY = 1400; MOVE_SPEED = 300; JUMP_V = 700; enemySpeedFactor = 0.75; lives = 5; }
    else if (mode === 'normal'){ GRAVITY = 1600; MOVE_SPEED = 320; JUMP_V = 620; enemySpeedFactor = 1; lives = 3; }
    else if (mode === 'hard'){ GRAVITY = 1800; MOVE_SPEED = 340; JUMP_V = 580; enemySpeedFactor = 1.35; lives = 2; }
  }

  // Input handling (keyboard)
  window.addEventListener('keydown', e=>{
    if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A'){ keys.left = true; }
    if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D'){ keys.right = true; }
    if (e.code === 'Space' || e.key === 'w' || e.key === 'W' || e.key === 'ArrowUp'){ keys.jump = true; }
    // quick pause
    if (e.key === 'p'){ togglePause(); }
  });
  window.addEventListener('keyup', e=>{
    if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A'){ keys.left = false; }
    if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D'){ keys.right = false; }
    if (e.code === 'Space' || e.key === 'w' || e.key === 'W' || e.key === 'ArrowUp'){ keys.jump = false; }
  });

  // Mobile controls events
  function setupTouchButton(btn, onDown, onUp){
    let active = false;
    const start = (e) => { e.preventDefault(); active = true; onDown(); };
    const end = (e) => { if(active){ active = false; onUp(); } };
    btn.addEventListener('touchstart', start, {passive:false});
    btn.addEventListener('pointerdown', start);
    window.addEventListener('touchend', end);
    window.addEventListener('pointerup', end);
    window.addEventListener('touchcancel', end);
  }
  setupTouchButton(leftBtn, ()=>touchState.left=true, ()=>touchState.left=false);
  setupTouchButton(rightBtn, ()=>touchState.right=true, ()=>touchState.right=false);
  setupTouchButton(jumpBtn, ()=>touchState.jump=true, ()=>touchState.jump=false);

  // Menu handlers
  startBtn.addEventListener('click', ()=>{
    document.activeElement.blur();
    const dif = difficultySelect.value;
    const lvl = parseInt(levelSelect.value || '0',10);
    applyDifficulty(dif);
    loadLevel(lvl);
    hideMenu();
    running = true;
    paused = false;
    lastTime = performance.now();
    gameLoop();
  });
  howBtn.addEventListener('click', ()=>{
    alert("Controls:\n\nDesktop: A/D or ‚Üê/‚Üí to move, Space to jump.\nMobile: use the on-screen buttons. Double jump is available depending on timing.\nCollect coins, avoid enemies, reach the finish line to clear a level.\n\nDifficulty affects jump gravity and enemy speed.");
  });

  pauseBtn.addEventListener('click', togglePause);
  restartBtn.addEventListener('click', ()=>{ if(!running) return; loadLevel(currentLevelIndex); });

  function hideMenu(){ menu.style.display = 'none'; document.getElementById('mobileControls').style.display = window.innerWidth<900 ? 'flex' : 'none'; }
  function showMenu(){ menu.style.display = 'flex'; document.getElementById('mobileControls').style.display = 'none'; running=false; }

  showMenu();

  // Messages
  let msgTimeout = null;
  function showMessage(text, ms=1200){
    msg.style.display = 'block'; msg.textContent = text;
    clearTimeout(msgTimeout);
    if (ms>0) msgTimeout = setTimeout(()=> msg.style.display='none', ms);
  }

  // Physics & collision helpers
  function pointInRect(px,py,rect){ return px>=rect.x && px<=rect.x+rect.w && py>=rect.y && py<=rect.y+rect.h; }
  function sweptAABB(player, dt){
    // Basic continuous collisions by stepping small substeps
    const steps = Math.max(1, Math.ceil((Math.abs(player.vx*dt)+Math.abs(player.vy*dt))/20));
    const sx = player.vx*dt/steps, sy = player.vy*dt/steps;
    for(let i=0;i<steps;i++){
      player.x += sx;
      // horizontal collisions with platforms
      platforms.forEach(p=>{
        if (rectsOverlap(player, p)){
          if (sx > 0) player.x = p.x - player.w - 0.001;
          else if (sx < 0) player.x = p.x + p.w + 0.001;
          player.vx = 0;
        }
      });
      player.y += sy;
      // vertical collisions
      player.onGround = false;
      platforms.forEach(p=>{
        if (rectsOverlap(player, p)){
          if (sy > 0){
            player.y = p.y - player.h - 0.001;
            player.vy = 0; player.onGround = true; player.canDoubleJump = true;
          } else if (sy < 0){
            player.y = p.y + p.h + 0.001;
            player.vy = 0;
          }
        }
      });
    }
  }

  // Main loop
  function gameLoop(now=performance.now()){
    if (!running) return;
    if (paused){ lastTime = now; requestAnimationFrame(gameLoop); return; }

    const dt = Math.min(0.035, (now - lastTime)/1000); // clamp dt
    lastTime = now;

    // Input combining keyboard + touch
    const left = keys.left || touchState.left;
    const right = keys.right || touchState.right;
    const jumpPressed = (keys.jump || touchState.jump);

    // Horizontal movement
    if (left && !right) player.vx = -MOVE_SPEED;
    else if (right && !left) player.vx = MOVE_SPEED;
    else player.vx = 0;

    // Jump handling: simple pressed edge detection
    if (jumpPressed && !player._jumpHeld){
      if (player.onGround){
        player.vy = -JUMP_V; player.onGround = false; player.canDoubleJump = true;
      } else if (player.canDoubleJump){
        player.vy = -JUMP_V * 0.9; player.canDoubleJump = false;
      }
      player._jumpHeld = true;
    }
    if (!jumpPressed) player._jumpHeld = false;

    // Apply gravity
    player.vy += GRAVITY * dt;

    // Movement & collision
    sweptAABB(player, dt);

    // Keep player within world vertical bounds
    if (player.y > 2000){
      // fell out of world
      loseLife();
    }

    // Enemies AI - simple patrol
    enemiesArray.forEach(e=>{
      e.x += e.speed * e.dir * dt;
      if (e.x < e.baseX - e.patrolW/2){ e.x = e.baseX - e.patrolW/2; e.dir = 1; }
      if (e.x > e.baseX + e.patrolW/2){ e.x = e.baseX + e.patrolW/2; e.dir = -1; }
    });

    // Collisions: player with coins
    coinsArray.forEach(c=>{
      if (!c.picked){
        const cRect = {x:c.x-14,y:c.y-14,w:28,h:28};
        if (rectsOverlap(player, cRect)){
          c.picked = true; coins++; score += 20; updateHUD();
          // small pop
        }
      }
    });

    // Collisions: player with enemies
    enemiesArray.forEach(e=>{
      const eRect = {x:e.x-22,y:e.y-28,w:44,h:48};
      if (rectsOverlap(player, eRect) && player.invulnTime <= 0){
        // determine if player stomped the enemy
        if (player.vy > 120 && (player.y + player.h - 6) <= (eRect.y + 10)){
          // stomp: enemy defeated
          score += 80; updateHUD();
          // remove enemy (mark inactive)
          e.dead = true;
          player.vy = -JUMP_V * 0.6; // bounce
        } else {
          // take damage
          player.invulnTime = 1.2;
          loseLife();
        }
      }
    });
    enemiesArray = enemiesArray.filter(e=>!e.dead);

    // invulnerability timer
    if (player.invulnTime > 0) player.invulnTime -= dt;

    // Finish line
    if (player.x >= finishX){
      // level cleared
      score += 200; updateHUD();
      showMessage('Level Complete!', 1400);
      setTimeout(()=> {
        currentLevelIndex++;
        if (currentLevelIndex >= levels.length){
          showMessage('You beat JumpQuest.Lite! üéâ', 3500);
          showMenu();
        } else {
          loadLevel(currentLevelIndex);
        }
      }, 800);
      return;
    }

    // Camera follow (smooth)
    const targetX = player.x - canvas.width/2 + player.w/2;
    const targetY = 0; // we keep vertical camera fixed for simplicity, but could follow Y
    camera.x += (targetX - camera.x) * camera.smooth;
    camera.y += (targetY - camera.y) * camera.smooth;

    // Draw
    render();

    requestAnimationFrame(gameLoop);
  }

  // Lose life routine
  function loseLife(){
    lives--;
    updateHUD();
    showMessage('You died!', 900);
    if (lives <= 0){
      showMessage('Game Over ‚Äî returning to menu', 1600);
      setTimeout(()=> {
        showMenu();
      }, 1600);
    } else {
      // respawn at start of level spawn
      const L = levels[currentLevelIndex];
      player.x = L.spawn.x; player.y = L.spawn.y; player.vx=0; player.vy=0;
      player.invulnTime = 1.0;
    }
  }

  // Rendering
  function render(){
    // clear
    ctx.clearRect(0,0,canvas.width,canvas.height);

    // world-to-screen transform
    ctx.save();
    ctx.translate(-Math.round(camera.x), -Math.round(camera.y));

    // background parallax sky
    drawParallax();

    // draw platforms
    platforms.forEach(p=>{
      roundRect(ctx, p.x, p.y, p.w, p.h, 6);
      ctx.fillStyle = '#1b2b3a';
      ctx.fill();
      ctx.lineWidth = 2;
      ctx.strokeStyle = '#071722';
      ctx.stroke();
      // walkway texture lines
      ctx.beginPath();
      for(let i=0;i<Math.floor(p.w/24);i++){
        ctx.moveTo(p.x + i*24, p.y + 6);
        ctx.lineTo(p.x + i*24 + 12, p.y + p.h - 6);
      }
      ctx.strokeStyle = 'rgba(255,255,255,0.02)'; ctx.lineWidth = 1; ctx.stroke();
    });

    // coins
    coinsArray.forEach(c=>{
      if (c.picked) return;
      const cx = c.x, cy = c.y;
      // gold coin circle
      ctx.beginPath(); ctx.fillStyle = '#ffd166'; ctx.arc(cx, cy, 12, 0, Math.PI*2); ctx.fill();
      ctx.lineWidth = 3; ctx.strokeStyle = '#c98f2a'; ctx.stroke();
      // shine
      ctx.beginPath(); ctx.fillStyle = 'rgba(255,255,255,0.22)'; ctx.arc(cx-4, cy-6, 4, 0, Math.PI*2); ctx.fill();
    });

    // enemies
    enemiesArray.forEach(e=>{
      const ex = e.x, ey = e.y;
      // body
      ctx.fillStyle = '#8b1f2b';
      roundRectFill(ctx, ex-22, ey-28, 44, 48, 10);
      // eye
      ctx.fillStyle = '#fff'; ctx.fillRect(ex+6, ey-16, 6, 6);
      ctx.fillStyle = '#000'; ctx.fillRect(ex+8, ey-14, 2, 2);
      // simple shadow
      ctx.beginPath(); ctx.ellipse(ex, ey+30, 30, 8, 0, 0, Math.PI*2);
      ctx.fillStyle = 'rgba(0,0,0,0.25)'; ctx.fill();
    });

    // finish line flag
    drawFinishLine(finishX);

    // player with slight bob when invuln
    ctx.save();
    const px = player.x, py = player.y;
    if (player.invulnTime > 0){
      ctx.globalAlpha = 0.5 + 0.5 * Math.sin(performance.now()/80);
    }
    drawPlayer(px, py);
    ctx.restore();

    // foreground (optional)
    ctx.restore();

    // HUD overlays drawn in DOM (not on canvas) to avoid overlapping ‚Äî nothing further here.
  }

  function drawParallax(){
    // sky bands
    const w = canvas.width*2;
    const bandOffset = (camera.x * 0.1) % 500;
    for(let i=0;i<4;i++){
      ctx.fillStyle = ['#0f2a3a','#0b2341','#07203a','#031724'][i] || '#031724';
      ctx.fillRect(camera.x * 0.02, i*120, 5000, 140);
    }
    // distant mountains
    ctx.fillStyle = '#092033';
    ctx.beginPath(); ctx.moveTo(0,420); ctx.lineTo(320,260); ctx.lineTo(640,420); ctx.lineTo(0,420); ctx.fill();
    ctx.beginPath(); ctx.moveTo(600,420); ctx.lineTo(940,320); ctx.lineTo(1280,420); ctx.fill();
  }

  function drawFinishLine(x){
    // pole
    ctx.fillStyle = '#222';
    ctx.fillRect(x-6, 200, 12, 360);
    // banner
    ctx.fillStyle = '#06d6a0';
    ctx.fillRect(x, 200, 140, 36);
    ctx.fillStyle = '#072b1e';
    ctx.font = 'bold 20px sans-serif';
    ctx.textBaseline = 'middle';
    ctx.fillText('FINISH', x+12, 218);
  }

  function drawPlayer(x,y){
    // simple sprite
    // torso
    roundRectFill(ctx, x, y, player.w, player.h, 8);
    // face
    ctx.fillStyle = '#ffd';
    ctx.fillRect(x+8, y+10, 8, 8);
    ctx.fillRect(x+24, y+10, 8, 8);
    // boots
    ctx.fillStyle = '#2b2b2b'; ctx.fillRect(x+4, y+player.h-10, 14, 8); ctx.fillRect(x+22, y+player.h-10, 14, 8);
    // simple shadow
    ctx.beginPath(); ctx.ellipse(x+player.w/2, y+player.h+14, 30, 8, 0, 0, Math.PI*2);
    ctx.fillStyle = 'rgba(0,0,0,0.25)'; ctx.fill();
  }

  // Drawing helpers
  function roundRect(ctx, x, y, w, h, r){
    ctx.beginPath();
    ctx.moveTo(x+r, y);
    ctx.arcTo(x+w, y, x+w, y+h, r);
    ctx.arcTo(x+w, y+h, x, y+h, r);
    ctx.arcTo(x, y+h, x, y, r);
    ctx.arcTo(x, y, x+w, y, r);
    ctx.closePath();
  }
  function roundRectFill(ctx, x, y, w, h, r){
    roundRect(ctx, x, y, w, h, r); ctx.fill();
  }

  // UI helpers: Pause
  function togglePause(){
    if (!running) return;
    paused = !paused;
    pauseBtn.textContent = paused ? 'Resume' : 'Pause';
    showMessage(paused ? 'Paused' : '', paused ? 99999 : 950);
    if (!paused) msg.style.display = 'none';
  }

  // Ensure GUI positions do not overlap on tiny screens
  function fixGuiLayout(){
    // If canvas height small, reposition top controls to right side to avoid overlapping HUD
    const cRect = canvas.getBoundingClientRect();
    const topControlsEl = document.getElementById('topControls');
    if (cRect.width < 560){
      topControlsEl.style.left = '';
      topControlsEl.style.right = '12px';
      topControlsEl.style.transform = 'none';
    } else {
      topControlsEl.style.left = '50%';
      topControlsEl.style.right = '';
      topControlsEl.style.transform = 'translateX(-50%)';
    }
  }
  window.addEventListener('resize', fixGuiLayout); fixGuiLayout();

  // Pre-start: set difficulty default
  applyDifficulty(difficultySelect.value);

  // Expose some functions for console debugging (optional)
  window._JumpQuest = {
    loadLevel: (n) => { if (n>=0 && n<levels.length) loadLevel(n); },
    getState: () => ({score, coins, lives, level:currentLevelIndex+1})
  };

  // Auto-play demo on small pause, helpful when user leaves menu open: rotates parallax etc.
  // (Nothing else)
})();
</script>
</body>
</html>